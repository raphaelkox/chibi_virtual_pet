/*
This is an example of how to use the OLED 128x64 I2C with SSD1306 driver using the Adafruit library.
It also applies to the 128x32 version, but not all components would fit the smaller screen.

Pins:
 * GND = GND
 * VCC = 5V
 * SCL = A5
 * SDA = A4

You can connect VCC to 3.3V to reduce the amount of high pitched noise that the display produces.*/

#include <Adafruit_GFX.h>  // Include core graphics library for the display
#include <Adafruit_SSD1306.h>  // Include Adafruit_SSD1306 library to drive the display

Adafruit_SSD1306 display(128, 64);  // Create display

//STATES
#define ST_IDLE           0
#define ST_INFO_STATUS    1
#define ST_INFO_FOOD      2
#define ST_INFO_TOY       3
#define ST_INFO_PET       4
#define ST_FOOD_SELECT    5
#define ST_ANIM           6

//SPRITES
#define BMP_ICON_INFO     0
#define BMP_ICON_FOOD     1
#define BMP_ICON_TOY      2
#define BMP_ICON_BATH     3
#define BMP_ICON_LIGHT    4
#define BMP_ICON_PET      5
#define BMP_INFO_FOOD     6
#define BMP_INFO_TOY      7
#define BMP_INFO_PET      8
#define BMP_GRASS_BG      9
#define BMP_FOOD_SEL      10

#define BMP_COUNT         11

#define SPRITE_COUNT      2

typedef struct bmp{
  const unsigned char * data;
  uint16_t wd;
  uint16_t ht;
}bmp;

bmp bmps[BMP_COUNT];

// 'icon_1_info', 8x8px
const unsigned char icon_info [] PROGMEM = {
  0x7e, 0x81, 0x99, 0x81, 0x99, 0x99, 0x81, 0x7e
};
// 'icon_2_food', 8x8px
const unsigned char icon_food [] PROGMEM = {
  0x00, 0x03, 0x15, 0x29, 0x3c, 0x78, 0x60, 0x80
};
// 'icon_3_toy', 8x8px
const unsigned char icon_toy [] PROGMEM = {
  0x00, 0x10, 0x7c, 0x7c, 0x3e, 0x7c, 0x6c, 0x00
};
// 'icon_4_bath', 8x8px
const unsigned char icon_bath [] PROGMEM = {
  0x38, 0x4c, 0x5e, 0x40, 0x4a, 0x48, 0x42, 0x4a
};
// 'icon_5_light', 8x8px
const unsigned char icon_light [] PROGMEM = {
  0x10, 0x82, 0x38, 0x44, 0x45, 0x54, 0x38, 0x38
};
// 'icon_6_pet', 8x8px
const unsigned char icon_pet [] PROGMEM = {
  0x00, 0x66, 0x9f, 0xbf, 0xff, 0x7e, 0x3c, 0x18
};

// 'info_food', 16x16px
const unsigned char info_food [] PROGMEM = {
  0x00, 0x00, 0x00, 0x06, 0x00, 0x0e, 0x01, 0x9c, 0x03, 0xd0, 0x05, 0xe0, 0x06, 0xf0, 0x0f, 0xf8, 
  0x0f, 0xf8, 0x16, 0xf0, 0x1b, 0x60, 0x3f, 0x80, 0x36, 0x00, 0x78, 0x00, 0x60, 0x00, 0x00, 0x00
};

// 'info_toy', 16x16px
const unsigned char info_toy [] PROGMEM = {
  0x00, 0x00, 0x01, 0xe0, 0x01, 0xe0, 0x1f, 0xfe, 0x1f, 0xfe, 0x1f, 0xfe, 0x1f, 0xfe, 0x7f, 0xf8, 
  0x7f, 0xf8, 0x7f, 0xf8, 0x7f, 0xf8, 0x1f, 0xfe, 0x1f, 0xfe, 0x1e, 0x1e, 0x1e, 0x1e, 0x00, 0x00
};

// 'info_pet', 16x16px
const unsigned char info_pet [] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x1c, 0x38, 0x36, 0x7c, 0x6f, 0xfe, 0x6f, 0xfe, 0x7f, 0xfe, 0x7f, 0xfe, 
  0x3f, 0xfc, 0x1f, 0xf8, 0x0f, 0xf0, 0x07, 0xe0, 0x03, 0xc0, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00
};

// 'grass_bg', 48x4px
const unsigned char grass_bg [] PROGMEM = {
  0x02, 0x00, 0x00, 0x02, 0x00, 0x00, 0x1a, 0x80, 0x00, 0x36, 0x80, 0x00, 0x0f, 0x00, 0x00, 0x1f, 
  0x80, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

// 'screen_food_sel', 96x64px
const unsigned char food_sel [] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xfc, 
  0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xfc, 0x00, 0xf0, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0x0c, 0x03, 0x03, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x3f, 0xfc, 0x0c, 0x03, 0x03, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xc3, 0x00, 0x0c, 0x00, 
  0xcf, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xc3, 0x00, 0x0c, 0x00, 0xcf, 0xfc, 0x00, 0x00, 
  0x00, 0x00, 0x3f, 0xc0, 0x03, 0x00, 0x0c, 0x00, 0xff, 0xf3, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xc0, 
  0x03, 0x00, 0x0c, 0x00, 0xff, 0xf3, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xff, 0xff, 0xc0, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc0, 0x00, 
  0x00, 0x03, 0xc0, 0x00, 0xc0, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x03, 0xc0, 0x00, 
  0xc0, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x3f, 0xc0, 0xc0, 0x03, 0x00, 0x00, 
  0xff, 0xf3, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xc0, 0xc0, 0x03, 0x00, 0x00, 0xff, 0xf3, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x3f, 0xc0, 0x03, 0x00, 0x00, 0xcf, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 
  0xc0, 0x03, 0x00, 0x00, 0xcf, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0x00, 0x03, 
  0x03, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0x00, 0x03, 0x03, 0xfc, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xfc, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x03, 0xff, 0xfc, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 
  0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0xcc, 0xfc, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0xcc, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x3f, 0xff, 0xfc, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 
  0xff, 0xfc, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x3f, 0xfc, 0x3c, 0xcc, 
  0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x3f, 0xfc, 0x3c, 0xcc, 0xfc, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x3f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 
  0xff, 0xf0, 0x3f, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x3f, 
  0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x3f, 0xfc, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x0f, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xc0, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xf3, 0x33, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xf3, 0x33, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf0, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xfc, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xc0, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

//ANIMATIONS
typedef struct frame {
  uint8_t px;
  uint8_t py;
  uint8_t spr;
  uint8_t t;
} frame;

typedef struct sprite{
  frame *frames;
  bool active;
  uint8_t current_frame = 0;
  uint8_t frame_time = 0;
  uint8_t frame_count;
  bool is_loop = false;  
  bool frame_flag = false;
  bool end_flag = false;
} sprite;

frame test[4];

//HW SPRITES
sprite sprites[SPRITE_COUNT];

//CONSTROLS
const int btn0 = 2;
bool b0state = 0;
bool b0Lstate = 0;
bool change_action = false;

const int btn1 = 3;
bool b1state = 0;
bool b1Lstate = 0;
bool confirm_action = false;

const int btn2 = 5;
bool b2state = 0;
bool b2Lstate = 0;
bool cancel_action = false;

uint8_t cursorX = 0;
uint8_t cursorY = 0;
uint8_t cursor = 0;

void move_cursor(){
  cursorY++;  

  if(cursorY > 3){
    cursorX = 1 - cursorX;
    cursorY = cursorX;
  }
  
  cursor++;
  if(cursor > 6) cursor = 0;
}

void keys(){
  //change option
  b0Lstate = b0state;
  b0state = digitalRead(btn0);   
  change_action = (b0state == LOW && b0Lstate == HIGH ); //just pressed

  //ok
  b1Lstate = b1state;
  b1state = digitalRead(btn1);
  confirm_action = (b1state == LOW && b1Lstate == HIGH ); //just pressed

  //cancel / back
  b2Lstate = b2state;
  b2state = digitalRead(btn2);
  cancel_action = (b2state == LOW && b2Lstate == HIGH ); //just pressed
}

uint8_t getX(uint8_t x){
  return 5 + (x * 110);
}

uint8_t getY(uint8_t y){
  return 12 + ((y - 1) * 16);
}

// SYSTEM
const int dbg0led = 6;
const int dbg1led = 7;
const int dbg2led = 8;

uint8_t lastState = -1;
uint8_t state = 0;
uint8_t nextState = ST_ANIM;
bool transition;

uint8_t food = 4;
uint8_t happy = 4;
uint8_t pet = 4;

uint8_t regA;
uint8_t regB;

/*struct State{
  State(){}
  virtual void doState();
};*/

//GRAPHICS
void draw_bmp(uint16_t x, uint16_t y, bmp bmp, uint16_t color){
  display.drawBitmap(x, y, bmp.data, bmp.wd, bmp.ht, color);
}

void draw_frame(frame f, uint16_t color){
  draw_bmp(16 + f.px, f.py, bmps[f.spr], color);
}

void update_sprites(){
  
  for(uint8_t n = 0; n < SPRITE_COUNT; n++){
    sprite *spr;

    spr = &sprites[n];
        
    if(spr && spr->active){
      //clean  flags
      spr->end_flag = false;
      spr->frame_flag = false;  
      
      draw_frame(spr->frames[spr->current_frame], WHITE);

      spr->frame_time++;

      if(spr->frame_time > spr->frames[spr->current_frame].t){
        spr->frame_time = 0;

        spr->current_frame++;
        spr->frame_flag = true;

        if(spr->current_frame >= spr->frame_count){
          spr->current_frame = 0;

          if(!spr->is_loop){
            spr->active = false;
          }

          spr->end_flag = true;
        }
      }
    }
  }
}

//STATES
void state_idle(){
   display.setCursor(24,10);
   display.print("Idle");
   
   if(change_action) move_cursor();
   
   if(confirm_action){      
      switch(cursor){
        case 1:
          nextState = ST_INFO_STATUS;
          break;
        case 2:
          nextState = ST_ANIM;
      }   
   }
   
   if(cancel_action) {
      cursorX = 0;
      cursorY = 0;
      cursor = 0;
   }   
}

//info status
void state_info_status(){
   display.setCursor(29,10);
   display.print("Status");

   if(change_action){
    nextState = 2;
   }
   if(cancel_action) {
      nextState = 0;
      cursorX = 0;
      cursorY = 0;
      cursor = 0;
   }
}

//info food
void state_info_food(){
   display.setCursor(40,10);
   display.print("Food");

  for(uint8_t c = 0; c < food; c++){
    draw_bmp(32 + (c * 16), 32, bmps[BMP_INFO_FOOD], WHITE);
  }
  
   if(change_action){
    nextState = 3;
   }
   if(cancel_action) {
      nextState = 0;
      cursorX = 0;
      cursorY = 0;
      cursor = 0;
   }
}

//info toy
void state_info_toy(){
   display.setCursor(34,10);
   display.print("Happy");

  for(uint8_t c = 0; c < happy; c++){
    draw_bmp(32 + (c * 16), 32, bmps[BMP_INFO_TOY], WHITE);
  }

   if(change_action){
    nextState = 4;
   }
   if(cancel_action) {
      nextState = 0;
      cursorX = 0;
      cursorY = 0;
      cursor = 0;
   }
}

//info pet
void state_info_pet(){
   display.setCursor(44,10);
   display.print("Pet");

   for(uint8_t c = 0; c < pet; c++){
    draw_bmp(32 + (c * 16), 32, bmps[BMP_INFO_PET], WHITE);
   }

   if(change_action){
    nextState = 1;
   }
   if(cancel_action) {
      nextState = 0;
      cursorX = 0;
      cursorY = 0;
      cursor = 0;
   }
}

//food_selection
void state_food_sel(){
  
}

//anim test
void state_anim(){

  if(transition){
    sprite s;

    s.frames = test;
    s.active = true;
    s.frame_count = 4;

    sprites[0] = s;
  }
  
  if(sprites[0].end_flag) { 
    nextState = 0;
    cursorX = 0;
    cursorY = 0;
    cursor = 0;
  }
}

//STATES ARRAY
void (*states[])(void) = {
  state_idle,
  state_info_status,
  state_info_food,
  state_info_toy,
  state_info_pet,
  state_food_sel,
  state_anim
};

void setup()   {                
   delay(100);
  // by default, we'll generate the high voltage from the 3.3v line internally! (neat!)
  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);  // initialize with the I2C addr 0x3D (for the 128x64)
  // init done

  // Clear the buffer.
  display.clearDisplay();
  
  pinMode(btn0, INPUT_PULLUP);
  pinMode(btn1, INPUT_PULLUP);
  pinMode(btn2, INPUT_PULLUP);
  pinMode(dbg0led, OUTPUT);
  pinMode(dbg1led, OUTPUT);
  pinMode(dbg2led, OUTPUT);
  
  display.setTextColor(WHITE);
  display.setTextSize(2);

  setup_bmp();
  setup_anims();  
}

void setup_bmp(){
  bmp b;
  
  b.data = icon_info;
  b.wd = 8;
  b.ht = 8;
  bmps[BMP_ICON_INFO] = b;
  
  b.data = icon_food;
  b.wd = 8;
  b.ht = 8;
  bmps[BMP_ICON_FOOD] = b;
  
  b.data = icon_toy;
  b.wd = 8;
  b.ht = 8;
  bmps[BMP_ICON_TOY] = b;
  
  b.data = icon_bath;
  b.wd = 8;
  b.ht = 8;
  bmps[BMP_ICON_BATH] = b;
  
  b.data = icon_light;
  b.wd = 8;
  b.ht = 8;
  bmps[BMP_ICON_LIGHT] = b;
  
  b.data = icon_pet;
  b.wd = 8;
  b.ht = 8;
  bmps[BMP_ICON_PET] = b;
  
  b.data = info_food;
  b.wd = 16;
  b.ht = 16;
  bmps[BMP_INFO_FOOD] = b;
  
  b.data = info_toy;
  b.wd = 16;
  b.ht = 16;
  bmps[BMP_INFO_TOY] = b;
  
  b.data = info_pet;
  b.wd = 16;
  b.ht = 16;
  bmps[BMP_INFO_PET] = b;
  
  b.data = grass_bg;
  b.wd = 48;
  b.ht = 4;
  bmps[BMP_GRASS_BG] = b;

  b.data = food_sel;
  b.wd = 96;
  b.ht = 64;
  bmps[BMP_FOOD_SEL] = b;
}

void setup_anims(){
  frame f;
  f.px = 16;
  f.py = 32;
  f.spr = BMP_INFO_FOOD;
  f.t = 2;
  test[0] = f;
  
  f.px = 32;
  f.py = 32;
  f.spr = BMP_INFO_TOY;
  f.t = 2;
  test[1] = f;
  
  f.px = 48;
  f.py = 32;
  f.spr = BMP_INFO_PET;
  f.t = 2;
  test[2] = f;
  
  f.px = 64;
  f.py = 32;
  f.spr = BMP_INFO_TOY;
  f.t = 2;
  test[3] = f;
}

void loop() {
  display.clearDisplay(); //clr screen

  keys();
  
  process_states();
  
  draw_ui();

  update_sprites();

  display.display();
}

void process_states(){
  transition = false;
  
   if(nextState != state){
      lastState = state;
      state = nextState;
      transition = true;
   }

  states[state]();  

   //led
   digitalWrite(dbg2led, (state & (1 << 0)));
   digitalWrite(dbg1led, (state & (1 << 1)));
   digitalWrite(dbg0led, (state & (1 << 2)));   
}

void draw_ui(){
  display.drawFastVLine(0, 0, 64, WHITE);
  display.drawFastVLine(127, 0, 64, WHITE);

  //draw internal borders
  display.drawRect(17, 1, 94, 62, WHITE);
  
  draw_bmp(getX(0), getY(1), bmps[BMP_ICON_INFO], WHITE);  
  draw_bmp(getX(0), getY(2), bmps[BMP_ICON_FOOD], WHITE);  
  draw_bmp(getX(0), getY(3), bmps[BMP_ICON_TOY], WHITE);  
  draw_bmp(getX(1), getY(1), bmps[BMP_ICON_BATH], WHITE);  
  draw_bmp(getX(1), getY(2), bmps[BMP_ICON_LIGHT], WHITE);  
  draw_bmp(getX(1), getY(3), bmps[BMP_ICON_PET], WHITE);  

  if(cursorY > 0){
    display.fillRect(getX(cursorX), getY(cursorY), 8, 8, INVERSE);   
  }

  draw_bmp(17, 58, bmps[BMP_GRASS_BG], WHITE);  
  draw_bmp(63, 58, bmps[BMP_GRASS_BG], WHITE);  
}
